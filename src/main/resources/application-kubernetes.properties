# Just to be backwards compatible with previous versions, this is set to "steve",
# since there might be already configured chargepoints expecting the older path.
# Otherwise, might as well be changed to something else or be left empty.
#
context.path = steve

# Database configuration
# Note: ${env.DB_HOST} syntax is for Maven's properties-maven-plugin during build
# Maven resource filtering will transform these to ${DB_HOST} for Spring Boot at runtime
db.ip=${env.DB_HOST}
db.port=${env.DB_PORT}
db.schema=${env.DB_DATABASE}
db.user=${env.DB_USERNAME}
db.password=${env.DB_PASSWORD}

# Credentials for Web interface access
#
auth.user=$ADMIN_USERNAME
auth.password=$ADMIN_PASSWORD

# The header key and value for Web API access using API key authorization.
# Both must be set for Web APIs to be enabled. Otherwise, we will block all calls.
#
webapi.key=$WEBAPI_KEY
webapi.value=$WEBAPI_VALUE

# Jetty configuration
#
server.host = 0.0.0.0
server.gzip.enabled = false

# Jetty HTTP configuration
#
http.enabled = true
http.port = 8180

# Spring Boot proxy configuration
# Tell Spring Boot to trust forwarded headers from the ingress controller
# This is needed when the application is behind a reverse proxy/load balancer
# Use 'native' strategy to use the framework's native support for forwarded headers
# server.forward-headers-strategy = native
# Note: server.use-forward-headers is deprecated in Spring Boot 2.2+
# The forward-headers-strategy handles this automatically

# External hostname configuration for absolute redirects
# If set, all redirects will use this hostname (and port if specified)
# This ensures redirects work correctly when behind a proxy
# Format: hostname (e.g., steve.lookout.evorg.com) or hostname:port
# Example: steve.lookout.evorg.com:27855
# Leave empty to use X-Forwarded-* headers (recommended when proxy sends them correctly)
# Note: With server.forward-headers-strategy = native, Spring Boot should use
# X-Forwarded-Host and X-Forwarded-Port automatically. This setting is a fallback.
server.external-hostname = ${EXTERNAL_HOSTNAME:}

# Jetty HTTPS configuration
#
https.enabled = false
https.port = 8443
keystore.path =
keystore.password =

# Enable HTTP request logging
logging.level.org.springframework.web=DEBUG
logging.level.org.eclipse.jetty=DEBUG
logging.level.org.springframework.web.servlet.DispatcherServlet=DEBUG

# When the WebSocket/Json charge point opens more than one WebSocket connection,
# we need a mechanism/strategy to select one of them for outgoing requests.
# For allowed values see de.rwth.idsg.steve.ocpp.ws.custom.WsSessionSelectStrategyEnum.
#
ws.session.select.strategy = ALWAYS_LAST

# if BootNotification messages arrive (SOAP) or WebSocket connection attempts are made (JSON) from unknown charging
# stations, we reject these charging stations, because stations with these chargeBoxIds were NOT inserted into database
# beforehand. by setting this property to true, this behaviour can be modified to automatically insert unknown
# stations into database and accept their requests.
#
# CAUTION: setting this property to true is very dangerous, because we will accept EVERY BootNotification or WebSocket
# connection attempt from ANY sender as long as the sender knows the URL and sends a valid message.
#
auto.register.unknown.stations = false

# if this field is set, it will take precedence over the default regex we are using in
# de.rwth.idsg.steve.web.validation.ChargeBoxIdValidator.REGEX to validate the format of the chargeBoxId values
#
charge-box-id.validation.regex =

### DO NOT MODIFY ###
db.sql.logging = false
profile = prod
